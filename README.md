# Bajo

Simple embeddable bytecode VM: C interpreter, Python-based assembler.

Bajo interpreter is designed for resource-limited platforms, including 32-bit MCUs.

The assembler is implemented in Python as an inner DSL.
Macro functions are used to make scripts more high-level.

The typical Bajo script is a few conditionals, branches, and host function calls.

## Example

Raw style:

```python
from bajo import Add, Mul, Exit, R, Script, Label, Mov, Sys02

skip = Label()

script = Script([
    Mov(R[0], 10),
    Add(R[1], R[0], 20),
    Mul(R[2], R[1], 30),
    BrLe(R[2], 1000, skip),
    Sys02(42, R[0], R[1]),
    skip,
    Exit()
])
```

More high-level style:

```python
from bajo import R, Script, when, Sys02

a = R[0]
b = R[1]
c = R[2]

def host_func_42(a, b):
    return Sys02(42, a, b)

script = Script(
    [
        a.set(10),
        b.set(a + 20),
        c.set(b * 30),
        when(
            c < 1000,
            then=host_func_42(a, b),
        ),
    ]
)
```

Result:

```python
>>> print(script)
  100000:       3d 01 51                Mov r0, #10
  100003:       01 09 03 a1             Add r1, r0, #20
  100007:       03 11 13 f1             Mul r2, r1, #30
  10000b:       1e 82 3e 23 29          BrGe #1000, r2, #5:<.L1>
  100010:       30 a2 02 03 13          Sys02 #42, r0, r1
.L1
  100015:       2d 01                   Exit #0
>>> print(bytes(script).hex())
3d0151010903a1031113f11e823e232930a20203132d01
```

## Key features

Bajo scripts are written in a custom assembly. There is no compiler by design. A Python-based assembler makes integrating with other projects easy.

If you're interested in a compiled solution with a MIPS-compatible bytecode, see [mipsvm](https://github.com/jkmnt/mipsvm).

### Register-based

Bajo is register-based. Or, better said, memory-based.
Registers are just aliases for a word-aligned memory.
Their number is effectively unlimited.

### Addressing modes

Each operand could be a memory, an immediate 32-bit value, or an indirect memory. Or even doubly indirect memory.

```python
Add(R[0], 10, R[1])

Add(R[0], R[1], R[2])

Add(R[0], R[1], M[R[2]])

Add(M[R[0] + M[R[1]]], M[R[2] + M[R[3] - M[R[5] + 4]]], -10) # crazy !
```

All instructions explicitly specify sources and targets.
There are no hidden assumptions, such as "result is always stored in R0".

### Instruction set

The instruction set is very basic: math, logic, bitwise operations, conditional branches, and host function calls.

A few high-level operations are included: `Abs`, `Min`, `Max`.

Instructions like `Min` and `Or` are accepting a variable number of arguments.

Some instructions are assembler-only, that is, they have no assigned bytecode. For example, assembler will rewrite the `less than` comparison as the `greater than` with the arguments swapped.

### Data types

The only official data type is a signed 32-bit integer. Assembler refuses to accept immediate unsigned values.

Despite that, some unsigned instructions are present.

If you really need to supply an unsigned integer, for example, an IPv4 address or timestamp, use the `cast_s32` helper.

### Address space

The code and the RAM share the same address space.
Normally, the RAM and registers start at address 0.

The code begins at some arbitrary high address above the RAM.

## Installation

Bajo VM assembler is not on a PyPI yet.
The dev version may be installed from GitHub:

```
pip install git+https://github.com/jkmnt/bajo.git
```

The C interpreter is provided in the source form. It has no dependencies.

## Instructions

For the instructions table, see the autogenerated **[VM instructions](docs/opcodes.md)**.

For the encoding format, see **[VM instructions encoding](docs/encoding.md)**.

## Using interpreter

For integrating the C interpreter into your project, see **[C interpreter API](docs/vmapi.md)**.

## Using assembler

While the `bajo` package is fully typed for usage with a typechecker and IDE code suggestions, examples in this document are without type hints to reduce noise.

### Code

The code is a collection of instructions, labels, read-only data, and directives.
Code items may nest another collections.

The `None` and the `False` are allowed too, but ignored. It's a way to implement feature toggles.

Intentionally complicated example:

```python

FEATURE_FORCE_ALIGN = True
FEATURE_INCLUDE_IT = False

code = [
    Add(R[0], R[1], R[2]),
    # nested list
    [
        # feature toggle
        FEATURE_FORCE_ALIGN and Align(4),
        Add(R[0], R[1], R[2]),
        # nested tuple
        (
            lab := Label(),
            Add(R[0], R[1], R[2]),
            Add(R[0], R[1], M[lab]),
            Add(R[0], R[1], R[2]),
            # list comprehension
            [R[i].set(i) for i in range(100, 200)],
        ),
        (
            (
                [
                    Mov(R[0], R[1]),
                    Mov(R[2], R[3]),
                ]
                if FEATURE_INCLUDE_IT
                else None
            ),
            # generator expression
            (
                [
                    R[i].set(i),
                    R[i + 1].set(R[i] * 2),
                ]
                for i in range(100, 200)
            ),
        ),
        D(b"1234"),
    ],
]

```

### Labels

Labels are used as forward references for instructions following them. Labels could be named.

### Script

The script is the container for a code.

```python
class Script:
    def __init__(self, code, *, env=None, implicit_exit=True): ...

    def encode(self): ...

    @property
    def result(self): ...

    def lst(self): ...

    @property
    def layout(self): ...
```

The script will use the default build configuration, unless the `env` is specified.
The terminating `Exit(0)` instruction is added automatically.
Use the `implicit_exit` flag to disable this behavior.

The `encode` method (or `bytes(script)`) produces a bytecode.

The `result` property is a sequence of assembled instructions.

The `lst` method (or `str(script)`) returns a listing.

The `layout` property contains \[an internal\] build result object.

# Registers/Memory

Instructions accept register (or memory) objects.
They are usually produced by `R` and `M` factories.

`Reg` and `Mem` objects overload most Python operators:

- `+`, `-`, `*`, `/`, `//`, `%`

- `>>`, `<<`, `&`, `|`, `^`

- `==`, `!=`, `<`, `>`, `<=`, `>=`

- `abs()`, `~`

Combine it with the `set` method to write a much more concise code:

```python
r0 = R[0]
r1 = R[1]
my_var = M[100]

r0.set(10) # produces Mov(R[0], 10)
r0.set(r0 + r1) # produces Add(R[0], R[0], R[1])

r0.set(r0, my_var)
r0.set(r0, M[my_var])

r0.set(r0 > r1) # produces TstGt(r0, r0, r1)

```

### R, M

Factories `R` and `M` produce registers and memory via square brackets subscription.
`M[i]` represents absolute memory, `R[a]` represents word-aligned memory.

```python
>>> bool(R[1] == M[4])
True
```

Examples:

```python
# assuming code starts from address 1024

label = Label()
resource = Data(b`1234`)


R[0] # Register 0. Same as M[0]
M[1] # Ram at address 1

M[1234] # Rom at address 1234
M[label] # Rom at address marked by `label`
M[resource] # Rom at address of `resource`

M[R[0]] # Memory at address contained in R[0]
M[R[0] + R[1]] # Memory at address contained in R[0] offsetted by R[1]
M[R[0] - 4] # Memory at address contained in R[0] - 4
```

`R` supports 'named' registers. Concrete register numbers are resolved from the `env` at build time.

```python

sp = R['sp']
lr = R['lr']
my_favorite_reg = R['mfr']

my_env = Env(..., named_registers = {'sp':13, 'lr':14, 'mfr':42})

script = Script([Add(sp, lr, my_favorite_reg)], env=my_env)

```

### Data in code

Data bytes may be placed in a code region by the `Bytes` class. Normally it is produced by the `D` factory.

```python

# c-style null-terminated string
data_string = D("Hello")

my_word = Label()

code = [
    # call host function #1, argument is address of string
    Sys11(1, M[data_string]),
    # call host function #2, argument is b'0xFFFFFFFF'
    Sys01(2, M[my_word]),
    Exit(),
    # place string here after code
    data,
    # place u32 constant marked by label
    my_word,
    D(0xFFFFFFFF)
]
```

The `D` accepts a code too:

```python

jt = Label()

code = [
    # Some code blocks
    f0 := Add(R[0], R[0], 10),
    ...
    f1 := Sub(R[1], R[1], 20),
    ...,
    # Jump to code block indexed by R4
    R[4].set(R[4] * 4),
    Jmp(M[jt + R[4]])

    # jumptable, each word is code address.
    jt,
    pack([
        D(f0),
        D(f1),
        ...
    ])
]
```

Use the `Bytes` class directly for more control.

### Directives

#### Align

```python
class Align:
    def __init__(n): ...
```

Place it into a code to align the next instruction to the `n` bytes.

### NoPad

```python
class NoPad: ...
```

Place it before an instruction to prevent the assembler from inserting any padding.

### Macro

A few useful macros are included in the package.

#### when

```python
def when(condition, then, otherwise=None): ...
```

This macro generates `then` and (optional) `otherwise` code blocks with conditional branches.
The name is chosen to avoid a conflict with reserved `if`/`else` Python keywords.
The `condition` should be a single-instruction comparison, for example, `R[0] >= 12`.

### case

```python
def case(cases, default=None): ...
```

This macro generates comparisons and conditional branches to code blocks
from the `cases` dict. The first matching case is executed. The optional `default` code
is executed if nothing matches.

```python
case(
    {
        R[0] == 10: R[3].set(1),
        R[1] < 1: R[4].set(2),
        R[2] != R[10]: [R[7].set(3), R[8].set(R[1] + R[2])]
    },
    default = R[0].set(-1)
)
```

#### Subroutine

```python
class Subroutine:

    def __init__(self, name=None): ...

    def define(self, body, *, save_regs = None, is_leaf=False): ...

    def call(self): ...

    @property
    def name(self): ...

    @property
    def code(self): ...
```

This macro wraps the `body` code
with a prologue, an epilogue, and a finish jump to the link register.

Instantiating the subroutine is "declaring" it.
Then the subroutine `body` code must be "defined" by calling the `define` method. This allows forward declarations.

The subroutine will push an optional list of `save_regs` registers on a stack in the prologue and pop them in the epilogue. Unless the `is_leaf` == True, the link register is stored on a stack too, allowing nested calls.

The link `lr` and the stack pointer `sp` registers are ”named” and resolved at the build time.

Use the `call` method to generate the branch-and-link to the subroutine address.

The `name` property holds a subroutine name - either supplied at creation or auto-assigned.

Include code in script via the `code` property. Or just insert it as is: iterating subroutines yields instructions.

```python
my_func = Subroutine()
my_func.define(
    [
        Add(R[0], R[1], R[2]),
        # recursive call !
        my_func(),
    ],
    save_regs=(R[0], R[1]),
)

s = Script([
    Mov(R[0], 1),
    # call
    my_func.call(),
    Exit(),
    # include code
    my_func.code,
])
```

### pack

```python
def pack(code): ...
```

The `pack` inserts `NoPad()` before each code item. This prevents the assembler from inserting any
padding.

## Build env

The `Env` class configures build-time options:

```python
class Env:
    def __init__(*, ram_region, code_region, named_registers, max_passes): ...
```

- `ram_region`: \[start:end\] of ram addresses
- `code_region`: \[start:end\] of code addresses
- `named_registers`: mapping of symbolic register names to concrete numbers
- `max_passes`: limits maximum number of build passes. Normally, a build completes as soon as the stable solution is found (3-4 passes).

Regions are half-open, that is, they include the start and exclude the end.

Current default:

```python
DEF_ENV = Env(
    ram_region=(0, 0x1_00_00),
    code_region=(0x1_00_00, 0x1_00_00_00_00),
    named_registers={"sp": 13, "lr": 14},
    max_passes=16,
)
```

## Recipes

### Automatically include used subroutines

Add bookeeping to the `Subroutine.call`:

```python

class UnforgettableSubroutine(Subroutine):
    _all = set()

    def call(self):
        UnforgettableSubroutine._all.add(self)
        return super().call()

    @classmethod
    def all_used(cls):
        # apply sort to have reproducible builds
        return sorted(cls._all, key=lambda x: x.name)

sub1 = UnforgettableSubroutine().define(...)
sub2 = UnforgettableSubroutine().define(...)
sub3 = UnforgettableSubroutine().define(...)

code = [
    sub1.call(),
    sub2.call(),
    sub3.call(),
    Exit(),
    UnforgettableSubroutine.all_used(),
]
```

### Entry point

The script interpreter may wish to know addresses of some instructions or data tables. Labels make it possible.

```python

main_lab = Label('main')

script = Script([
    # some data table go first
    dt := D(...),
    # some funcs
    Subroutine().define(...),
    # and finally entry point
    main_lab,
    # main code follows ...
    ...
    Exit()
])

# it's 'main' address
main_addr = script.layout[main]
# dt address
dt_addr = script.layout[dt]
# lookup by name is ok too
main_addr = script.layout['main']
```

Addresses are communicated to an app via the custom image header:

```python
header = struct.pack(
    "<III",
    script.layout.code_range[0],
    script.layout.code_range[1],
    script.layout["main"],
)

image = header + bytes(script)
```

### Lazy immediate values

Perhaps, immediate values are integer keys to be resolved at the build time.
Subclass the core `ImmExpr` class and implement the `result` method:

```python
class ServerId(ImmExp):

    def __init__(self, server_name):
        self.server_name = name

    def result(self, *args, **kwargs) -> int:
        with sqlite3.connect("servers.db") as conn:
            return conn.execute(f"SELECT id from servers WHERE name = ?", (self.server_name, )).fetchone()[0]


beta_lab = Label()

code = [
    # Call host system functions with server names resolved to integer keys.
    Sys01(1, ServerId("alpha")), # as immediate operand
    Sys01(1, M[beta_lab]), # load from code
    M[512].set(ServerId("gamma") + 1000) # just because we can
    Exit(),
    #
    beta_lab,
    D(ServerId("beta")),
    ...
]
```

Assembler will call the `result()` to learn ServerIds.
Potentially, a lot of times - take care to cache expensive calculations or IO.

## Answers

- _Bajo_ means _low_ in Spanish. Bajo VM is low-level indeed.
- The instruction set is not stable (yet?).
- The encoding is not stable (yet?).
- In rare circumstances, a script build may fail.
  Instructions have a variable size, so forward/backward references
  may cause oscillations. Although the assembler implements a strategy for breaking the cycles,
  a fail is still possible.
- The error reporting is not very informative.
- The build speed is non-goal.
